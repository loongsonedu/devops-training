### 一、实验目的


### 二、实验准备
* 用户devuser密码：devuser
* 安装git命令：sudo apt install git
### 三、Docker基础和核心原理
#### 1. Docker 简介
*   1.1 背景 </br>
   首先，我们需要了解一下Docker产生的背景。在我们的服务器中，可能需要部署多个Web应用，这些Web应用采用不同的JDK版本、Tomcat版本等。这样可能就会导致一个问题，当我们启动项目时，并没有按照我们的意愿来选择JDK的版本。因为其他Web应用的依赖配置对该应用产生了影响，每个应用之间的环境没有彼此隔离。

    当然，我们如果细心一点也可以做到每个应用只使用其所依赖的环境，可参考如何在一台计算机上安装多个 JDK ，看了之后你可能觉得好麻烦啊，为什么不一台计算机部署一个项目，这样就不会由于彼此依赖的环境没有被隔离而产生影响。

      很多时候，如果一台计算机上只部署一个项目，并不能够充分的利用CPU和内存，极大的浪费了硬件资源。为此，产生了虚拟机，虚拟机便是利用虚拟化技术以及宿主机的硬件资源，从而实现一台虚拟化的计算机，其效果可以说是等同于一台真实的计算机。

* docker技术产生的原因
* 开发和运维之间因为环境不同而导致的矛盾
* 集群环境下每台机器可轻松部署相同的应用
* DevOps（流水线）
#### 1.2 简介
* Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。

* Docker是世界领先的软件容器平台。开发人员利用Docker可以消除协作编码时"在我的机器上可正常工作"的问题。运维人员利用Docker可以在隔离容器中并行运行和管理应用，获得更好的计算密度。企业利用Docker可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。

#### 1.3 Docker 优点
* 简化程序 </br>
Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。

Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。

* 避免选择恐惧症</br>
如果你有选择恐惧症，还是资深患者。Docker 帮你打包你的纠结！比如Docker镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。

* 节省开支</br>
一方面， 云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。

#### 1.4 Docker 和虚拟机
<table>
        <tr>
            <th>特性</th>
            <th>Docker</th>
            <th>虚拟机</th>
        </tr>
       <tr>
          <th>启动</th>
          <th>秒级</th>
          <th>分钟级</th>
      </tr>
      <tr>
          <th>硬盘使用</th>
          <th>一般为MB</th>
          <th>一般为GB</th>
      </tr>
      <tr>
          <th>性能</th>
          <th>接近原本</th>
          <th>弱于原生</th>
      </tr>
 <tr>
          <th>系统支持量</th>
          <th>单机支持上千个</th>
          <th>一般是几十个</th>
      </tr>

</table>
### 2. Docker 架构
   Docker采用 C/S 架构，Client 通过接口与 Server 进程通信，从而实现容器的构建、运行和发布。

#### 2.1 Host（宿主机）
安装了Docker程序，并运行了Docker daemon的主机。

##### 2.1.1 Docker Daemon（Docker 守护进程）
运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互。

##### 2.1.2 Images（镜像）
将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。

      镜像分层结构


      位于下层的镜像称为父镜像(Parent Image)，最底层的称为基础镜像(Base lmage)。

      最上层为"可读写"层，其下的均为“只读”层。

##### 2.1.3 Containers（容器）
Docker的运行组件，启动一个镜像就是一个容器， 容器与容器之间相互隔离，并且互不影响。

#### 2.2 Docker Client（Docker客户端）
Docker命令行工具，用户是用Docker Client与Docker daemon进行通信并返回结果给用户，也可以使用其他工具通过Docker Api与Decker doemon通信。

#### 2.3 Registry（仓库服务注册）
经常会和仓库(Repository）混为一谈，实际上Registry上可以有多个仓库每个仓库可以看成是一个用户， 一个用户的仓库放了多个镜像。仓库分为公开仓库和私有仓库。



